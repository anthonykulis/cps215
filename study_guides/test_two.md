# Test Two Study Guide
This test will be 100 points.

This exam was built to test your ability to understand the subject matter and hence the algorithm coding portion is only 25 points yet there are another 25 points of code writing requirements that you *may or may not* have seen in class.

To further the understanding requirement, you will not sort any array values that you have already seen, but will be required to sort the array for each algorithm covered. You are required to have mastered the understanding of the algorithm versus memorizing my visual examples.

You will have to solve mathematics, but only mathematics that pertains to understanding the algorithm.

I believe this test is more complicated then the first, yet if you understand how to work with each algorithm you can easily get an A, but just barely. To truly master this test, you will have to have mastered each topic covered in the section.

The only partial credit that will be awarded for coding will be on **full** coding sections. Snippets will not be partially graded.

Showing the steps of each sort will not receive partial credit. The reason for this is because if you make an error in the first step, it will cascade downwards. It will be impossible to know if you just fudged it to work or actually simply made an error transposing values accidentally. Because of so, I have limited that portions points.

## Topics
The test is broken down into topics

1. Recursion
2. Generics
3. Selection Sort
4. Insertion Sort
5. Merge Sort
6. Quick Sort
7. Counting Sort
8. Radix Sort
9. Coding

### Recursion
* Be able to read and write recursive methods. Understand stoping conditions and how to manage values.
* Be able to understand how divide and conquer works and the benefits of divide.
* Understand levels of recursion and how to use the math to compute them from *n*
* Understand the different types of recursion and how to read and write them.

### Generics
* Be able to read and write generics that set bounds.
* Be able to identify and write generic symbols.

### Selection sort
* Be able to identify the time efficiency of selection sort for each of its major parts.
* Be able to show the steps of selection sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable

### Insertion Sort
* Be able to identify the time efficiency of insertion sort for each of its major parts
* Be able to show the steps of insertion sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable

### Merge Sort
* Be able to identify the time efficiency of merge sort for each of its major parts
* Be able to show the steps of merge sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable.
* Understand why we use divide and conquer to solve this sorting algorithm.

### Quick Sort
* Be able to identify the time efficiency of quick sort for each of its major parts
* Be able to show the steps of quick sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable

### Counting Sort
* Be able to identify the time efficiency of counting sort for each of its major parts
* Be able to show the steps of counting sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable

### Radix Sort
* Be able to identify the time efficiency of radix sort for each of its major parts
* Be able to show the steps of radix sort
* Be able to identify the major extra data structure parts required to implement the algorithm and why we use them, if applicable

### Coding
Be able to code any of the 6 sorting algorithms in either iterative or recursion. Only techniques done in class will be subject to testing. This means if we did not implement an algorithm recursively, you will not have to implement the recursive version.
